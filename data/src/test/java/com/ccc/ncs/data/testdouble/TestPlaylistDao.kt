package com.ccc.ncs.data.testdouble

import com.ccc.ncs.database.dao.PlayListDao
import com.ccc.ncs.database.model.PlayListEntity
import com.ccc.ncs.database.model.reference.PlayListMusicCrossRef
import com.ccc.ncs.database.model.relation.PlayListWithMusics
import com.ccc.ncs.model.util.replace
import kotlinx.coroutines.flow.Flow
import kotlinx.coroutines.flow.MutableStateFlow
import kotlinx.coroutines.flow.first
import kotlinx.coroutines.flow.map
import kotlinx.coroutines.flow.update
import java.util.UUID

class TestPlaylistDao(
    private val musicDao: TestMusicDao
): PlayListDao() {
    private val entitiesStateFlow = MutableStateFlow(emptyList<PlayListWithMusics>())

    override suspend fun insertPlayList(playList: PlayListEntity): Long {
        entitiesStateFlow.update { old ->
            old + PlayListWithMusics(
                playList = playList,
                musics = emptyList()
            )
        }

        return entitiesStateFlow.first().lastIndex.toLong()
    }

    override fun getPlayList(id: UUID): Flow<PlayListWithMusics?> =
        entitiesStateFlow.map { list ->
            list.find { it.playList.id == id }
        }

    override fun getAutoGeneratedPlaylist(): Flow<PlayListWithMusics?> =
        entitiesStateFlow.map { list ->
            list.find { !it.playList.isUserCreated }
        }

    override fun getPlayListByRowId(rowId: Long): Flow<PlayListWithMusics?> =
        entitiesStateFlow.map { list ->
            list[rowId.toInt()]
        }

    override fun getAllPlayList(): Flow<List<PlayListWithMusics>> = entitiesStateFlow

    override suspend fun linkMusicToPlayList(crossRef: List<PlayListMusicCrossRef>) {
        crossRef.forEach { ref ->
            val updatedEntity = entitiesStateFlow.value.find { it.playList.id == ref.playListId }?.let { entity ->
                entity.copy(
                    playList = entity.playList,
                    musics = (entity.musics + musicDao.getMusic(ref.musicId).first())
                        .filterNotNull()
                        .distinctBy { it.music.id }
                )
            } ?: return@forEach

            entitiesStateFlow.update { entities ->
                val updatedIndex = entities.indexOfFirst { it.playList.id == updatedEntity.playList.id }
                entities.replace(updatedIndex, updatedEntity)
            }
        }
    }

    override suspend fun unLinkAllMusic(playListId: UUID) {
        val updatedEntity = entitiesStateFlow.value.find { it.playList.id == playListId }?.let { entity ->
            entity.copy(
                playList = entity.playList,
                musics = emptyList()
            )
        } ?: return

        entitiesStateFlow.update { entities ->
            val updatedIndex = entities.indexOfFirst { it.playList.id == updatedEntity.playList.id }
            entities.replace(updatedIndex, updatedEntity)
        }
    }

    override suspend fun unLinkMusic(musicId: UUID) {
        entitiesStateFlow.update { state ->
            state.map { entity ->
                entity.copy(
                    playList = entity.playList,
                    musics = entity.musics.filterNot { it.music.id == musicId }
                )
            }
        }
    }

    override suspend fun updatePlayList(playList: PlayListEntity) {
        entitiesStateFlow.update { state ->
            state.map { entity ->
                entity.copy(
                    playList = if (entity.playList.id == playList.id) playList else entity.playList,
                    musics = entity.musics
                )
            }
        }
    }

    override suspend fun deletePlayList(id: UUID) {
        entitiesStateFlow.update { state ->
            state.filterNot { it.playList.id == id }
        }
    }
}