package com.ccc.ncs.feature.play

import androidx.lifecycle.ViewModel
import androidx.lifecycle.viewModelScope
import com.ccc.ncs.data.repository.MusicRepository
import com.ccc.ncs.domain.model.PlayerState
import com.ccc.ncs.domain.model.RepeatMode
import com.ccc.ncs.domain.model.TIME_UNSET
import com.ccc.ncs.domain.repository.PlayListRepository
import com.ccc.ncs.domain.repository.PlayerRepository
import com.ccc.ncs.domain.usecase.GetPlayerStateUseCase
import com.ccc.ncs.model.Music
import com.ccc.ncs.model.PlayList
import com.ccc.ncs.model.util.reorder
import com.ccc.ncs.playback.PlayerController
import dagger.hilt.android.lifecycle.HiltViewModel
import kotlinx.coroutines.Job
import kotlinx.coroutines.flow.SharingStarted
import kotlinx.coroutines.flow.StateFlow
import kotlinx.coroutines.flow.filterIsInstance
import kotlinx.coroutines.flow.first
import kotlinx.coroutines.flow.map
import kotlinx.coroutines.flow.onStart
import kotlinx.coroutines.flow.stateIn
import kotlinx.coroutines.launch
import java.util.UUID
import javax.inject.Inject

@HiltViewModel
class PlayerViewModel @Inject constructor(
    private val playerController: PlayerController,
    private val playerRepository: PlayerRepository,
    private val playlistRepository: PlayListRepository,
    private val musicRepository: MusicRepository,
    getPlayerStateUseCase: GetPlayerStateUseCase
) : ViewModel() {

    val playerUiState: StateFlow<PlayerUiState> = getPlayerStateUseCase().map { playerState ->
        if (playerState == null) PlayerUiState.Idle
        else PlayerUiState.Success(playerState)
    }.onStart {
        val musics = playerRepository.playlist.first()?.musics
        val index = playerRepository.musicIndex.first()
        val position = playerRepository.position.first() ?: TIME_UNSET
        if (musics != null && index != null) {
            playerController.prepare(musics, index, position)
        }
    }.stateIn(
        scope = viewModelScope,
        started = SharingStarted.Eagerly,
        initialValue = PlayerUiState.Idle
    )

    // Player control functions
    fun playPause() {
        playerController.playPause()
    }
    fun prev() {
        playerController.previous()
    }
    fun next() {
        playerController.next()
    }
    fun setPosition(position: Long) {
        playerController.setPosition(position)
    }
    fun setShuffleMode(isOn: Boolean) {
        playerController.setShuffleMode(isOn)
    }
    fun setRepeatMode(repeatMode: RepeatMode) {
        playerController.setRepeatMode(repeatMode)
    }
    fun seekToMusic(musicIndex: Int) {
        playerController.seekTo(musicIndex)
    }

    fun updateMusicOrder(prevIndex: Int, currentIndex: Int) {
        viewModelScope.launch {
            val state = playerUiState.value as? PlayerUiState.Success ?: return@launch
            val prevPlayingMusicId = state.currentMusic?.id

            val prevMusicList = state.playlist.musics
            val reorderedMusicList = prevMusicList.reorder(prevIndex, currentIndex)

            playlistRepository.setPlayListMusics(state.playlist.id, reorderedMusicList)
            playerController.moveMediaItem(prevIndex, currentIndex)

            reorderedMusicList
                .indexOfFirst { it.id == prevPlayingMusicId }
                .takeIf { it > 0 }
                ?.let {
                    playerRepository.updateMusicIndex(it)
                }
        }
    }

    fun playPlayList(playList: PlayList, startIndex: Int = 0) {
        viewModelScope.launch {
            playerRepository.setPlaylist(playList.id)
            playerRepository.updateMusicIndex(startIndex)
            playerController.playMusics(playList.musics, startIndex)
        }
    }

    fun closePlayer() {
        viewModelScope.launch {
            playerController.stop()
            playerRepository.clear()
        }
    }

    fun addQueueToCurrentPlaylist(newMusicIds: List<UUID>): Job = viewModelScope.launch {
        val currentPlaylist = (playerUiState.value as? PlayerUiState.Success)?.playlist ?: return@launch
        val newMusics = musicRepository.getMusics(newMusicIds).first()
        val distinctNewMusics = newMusics.filterNot { currentPlaylist.musics.contains(it) }
        val updatedMusics = currentPlaylist.musics + distinctNewMusics
        playlistRepository.setPlayListMusics(currentPlaylist.id, updatedMusics)
        playerController.appendMusics(distinctNewMusics)
    }

    fun playMusicWithRecentPlaylist(musicIds: List<UUID>) {
        viewModelScope.launch {
            val playlist = playlistRepository.getAutoGeneratedPlayList()
            val newMusics = musicRepository.getMusics(musicIds).first()
            val updatedMusics = (playlist.musics - newMusics) + newMusics
            val startIndex = updatedMusics.indexOfFirst { musicIds.contains(it.id) }
            val updatedPlaylist = playlist.copy(musics = updatedMusics)
            playlistRepository.setPlayListMusics(playlist.id, updatedMusics)
            playPlayList(updatedPlaylist, startIndex)
        }
    }

    private fun playMusicWithCurrentPlaylist(musicId: UUID) {
        viewModelScope.launch {
            addQueueToCurrentPlaylist(listOf(musicId)).join()

            playerUiState
                .filterIsInstance<PlayerUiState.Success>()
                .first { it.playlist.musics.any { music -> music.id == musicId } }
                .let { state ->
                    val playMusicIndex = state.playlist.musics.indexOfFirst { it.id == musicId }
                    if (playMusicIndex >= 0) {
                        seekToMusic(playMusicIndex)
                    }
                }
        }
    }

    fun addToQueueAndPlay(musicId: UUID) {
        viewModelScope.launch {
            when (playerUiState.value) {
                is PlayerUiState.Idle -> playMusicWithRecentPlaylist(listOf(musicId))
                is PlayerUiState.Success -> playMusicWithCurrentPlaylist(musicId)
            }
        }
    }

    fun removeFromQueue(music: Music) {
        viewModelScope.launch {
            val currentPlaylist = (playerUiState.value as? PlayerUiState.Success)?.playlist ?: return@launch
            val updatedMusics = currentPlaylist.musics - music
            playlistRepository.setPlayListMusics(currentPlaylist.id, updatedMusics)
            playerController.removeMusic(music)
        }
    }
}





sealed interface PlayerUiState {
    object Idle : PlayerUiState
    data class Success(
        val playerState: PlayerState
    ) : PlayerUiState {
        val playlist by playerState::playlist
        val playbackState by playerState::playbackState
        val lyrics by playerState::lyrics
        val currentMusic by playerState::currentMusic
    }
}
